

独立分表，级联分表





数据库水平切分的实现原理解析－－－分库，分表，主从，集群，负载均衡器
http://zhengdl126.iteye.com/blog/419850





MYSQL分库分表总结
http://wentao365.iteye.com/blog/1740874

1，创建一个完整表存储着所有的成员信息

2，下面我们进行分表：这里我们分两个表tb_member1,tb_member2
 create table tb_member2 like tb_member1;

   3,创建主表tb_member
DROP table IF EXISTS tb_member;
create table tb_member(
id bigint primary key auto_increment ,
name varchar(20),
sex tinyint not null default '0'
)ENGINE=**MERGE** UNION=(tb_member1,tb_member2) INSERT_METHOD=LAST CHARSET=utf8 AUTO_INCREMENT=1 ;


分表的大概过程和步骤就是这样的，下面我们来看看分表的算法实现：

假设现在有一个应用系统可能会有100亿的用户量，另外一个表一般存储量在不超过100万的时候基本能保持良好性能，计算下来，我们需要1万张表，即分表为1万个表。

我们可以设计成：user_0~user_9999

在用户表里面我们有唯一的标示是用户id,我们尅设计一个小算法来实现用户id与访问表名的对应：

function getTable($id)

{

**   return 'user_'.sprintf('%d',($id >>20));**

}

解释一下：($id >> 20)表示将向右移位20位，（向右移动一位标示减少一半），printf('%d',$data)标示将数据按照十进制输出。

               即id为1~1048575（2的20次幂-1）时均访问user_0,1048576~2097152时访问user_1,以此类推.....

那么问题来了，如果用户更多怎么办，现在需要一个可扩展的方法：

function getTable($id,$bit,$seed){
**   return 'user_'.sprintf('%0{$bit}d',($id >> $seed));**
}
其中：$id为用户id,$bit标示表后缀的位数,$seed表示要移位的位数即：单个表能存储的记录条数。
这样就可以任意分表了。
 
 
总结：
     其实上面我们介绍的是水平分表的实施方法，还存在另一种方法叫做：垂直分表
     垂直分表：
      举例说明，在一个博客系统中，文章标题，作者，分类，创建时间等，是变化频率慢，查询次数多，而且最好有很好的实时性的数据，我们把它叫做冷数据。
　　　　而博客的浏览量，回复数等，类似的统计信息，或者别的变化频率比较高的数据，我们把它叫做活跃数据。
　　     我们进行纵向分表后：
　　　　　　1,存储引擎的使用不同，冷数据使用MyIsam 可以有更好的查询数据。活跃数据，可以使用Innodb ,可以有更好的更新速度。
　　　　　　2,对冷数据进行更多的从库配置，因为更多的操作是查询，这样来加快查询速度。对热数据，可以相对有更多的主库的横向分表处理。
　　　　　　3,对于一些特殊的活跃数据，也可以考虑使用memcache ,redis之类的缓存，等累计到一定量再去更新数据库.
分类: MYSQL



单库单表 
单库单表是最常见的数据库设计，例如，有一张用户(user)表放在数据库db中，所有的用户都可以在db库中的user表中查到。 

单库多表 
随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。 
可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。 

多库多表 
随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平区分。 



通过一系列的切分规则将数据水平分布到不同的DB或table中，在通过相应的DB路由 或者 table路由规则找到需要查询的具体的DB或者table，以进行Query操作。这里所说的“sharding”通常是指“水平切分”， 这也是本文讨 论的重点。具体将有什么样的切分方式呢和路由方式呢？行文至此，读者难免有所疑问，接下来举个简单的例子：我们针对一个Blog应用中的日志来说明， 比如日志文章（article）表有如下字段：


我们可以这样做，将user_id为 1～10000的所有的文章信息放入DB1中的article表中，将user_id为10001～20000的所有文章信息放入DB2中的 article表中，以此类推，一直到DBn。

比如user_id是234，利 用该才的规则，就应该定位到DB1，假如user_id是12343，利用该才的规则，就应该定位到DB2。以此类推，利用分库的规则，反向的路由到具体 的DB，这个过程我们称之为“DB路由”。

一定要自己实践，今天大神的各种问题，一定要细粒度的思考，山子

考虑到数据切分的DB设计，将违背这个通常的规矩和约束，为了切分，我们不得不在数据库的表中出现冗余字段，用 **作区分字段或者叫做分库的标记字段**

空间换时间，一下子呆了。。


article的例子中的user_id这样的字段（当然，刚才的例子并没有很好的体现出user_id的 **冗余性**，因为user_id这个字段即使就是不分库，也是要出现的，算是我们捡了便宜吧）。





